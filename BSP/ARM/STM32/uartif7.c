/*
* uartif7.c                                                 Version 5.4.0
*
* UART Interrupt-Driven Low-Level Driver Functions for STM32 Processor with
* HAL library.
*
* Copyright (c) 2012-2025 Micro Digital Inc.
* All rights reserved. www.smxrtos.com
*
* This software, documentation, and accompanying materials are made available
* under the Apache License, Version 2.0. You may not use this file except in
* compliance with the License. http://www.apache.org/licenses/LICENSE-2.0
*
* SPDX-License-Identifier: Apache-2.0
*
* This Work is protected by patents listed in smx.h. A patent license is
* granted according to the License above. This entire comment block must be
* preserved in all copies of this file.
*
* Support services are offered by MDI. Inquire at support@smxrtos.com.
*
* Author: Ralph Moore
*
*****************************************************************************/

#include "bbase.h"
#include "stm32f746xx.h"

#if SB_CFG_UARTI
#include "bsp.h"

#if SMX_CFG_SSMX
#pragma diag_suppress=Ta168 /* ignore warning that next line overrides existing prefix */
#pragma section_prefix = ".cp"
#endif

static UART_HandleTypeDef* huart;      /* HAL UART struct pointer */
static u8                  sb_in_byte; /* console input byte */
LCB_PTR                    sb_UartLSR;
extern PICB_PTR            opcon_pipe;
             
#if SMX_CFG_SSMX
#pragma default_function_attributes = @ ".sys.text"
#endif

void sb_UartLSRMain(u32 key)
{
   smx_PipePutPktWait(opcon_pipe, &key, SMX_TMO_NOWAIT);
   HAL_UART_Receive_IT(huart, &sb_in_byte, 1);
}

void sb_UartISR(void)
{
   smx_ISR_ENTER();
   HAL_UART_IRQHandler(huart);
   if (sb_in_byte > 0)
   {
      smx_LSR_INVOKE(sb_UartLSR, sb_in_byte);
      sb_in_byte = 0;
   }
   smx_ISR_EXIT();
}

#if !defined(SMX_STM32CUBEMX) /*<1>*/   
void sb_UartInit(u32 parity, u32 dbit, u32 sbit)
{
   /* initialize huart no parity, 8 bits, and 1 stop bit*/
   memset(huart, 0, sizeof(UART_HandleTypeDef));
   huart->Instance = USART1;
   huart->Init.BaudRate = SB_CON_BAUD;
   huart->Init.Mode = UART_MODE_TX_RX;
   huart->Init.WordLength = UART_WORDLENGTH_8B;

   /* initialize and enable UART */
   if (HAL_UART_Init(huart) != HAL_OK)
   {
      smx_HeapFree(&huart);
   }
}
#endif

void sb_UartOpen(u32 parity, u32 dbit, u32 sbit)
{
   /* allocate huart structure */
  #if SMX_CFG_SSMX
   huart = (UART_HandleTypeDef*)smx_HeapMalloc(sizeof(UART_HandleTypeDef), 1, cp_hn);
  #else
   huart = (UART_HandleTypeDef*)smx_HeapMalloc(sizeof(UART_HandleTypeDef));
  #endif
   /* enable UART operation */
   sb_UartInit(parity, dbit, sbit);
   sb_UartLSR = smx_LSRCreate(sb_UartLSRMain, SMX_FL_TRUST, "sb_UartLSR");
   HAL_UART_Receive_IT(huart, &sb_in_byte, 1);
   sb_IRQVectSet(USART1_IRQn, sb_UartISR);
   sb_IRQUnmask(USART1_IRQn);
}

#if SMX_CFG_SSMX 
#pragma default_function_attributes = 
#endif

void sb_UartOutData(u8* psrc, u32 len)
{
   HAL_UART_Transmit_IT(huart, (u8*)psrc, len);
   while (huart->gState != HAL_UART_STATE_READY){}
}
#endif /* SB_CFG_UARTI */

/* Notes:
   1. MX_USART1_UART_Init() is generated by STM32CubeMX.
*/